function [output]=calculate_qJP(input1,input2,input3,input4,input5,input6)
% Compute q value starting from experimental angles
% Inputs are in degrees
% input1 : gamma; input2 : alpha; input3 : chi
% input4 : phi; input5: omega; input6 : delta

 
if ((nargin ~= 6))
 disp(' ');   
 disp(sprintf('Please supply the values for the six angles!'));
 disp(sprintf('calc_angle(gam,alp,chi,phi,om,del)!'));

 
 return
end

 
%% Parameters
lambda = 1.7537; %in nm, wavelength
aa = 310; %in nm
bb = 310; %in nm
cc = 1; %in nm
alpha1 = pi/2; %in rad
beta1=pi/2; %in rad
g=pi/2; %in rad
VV=(aa*bb*cc*sqrt(1 - cos(alpha1)^2 - cos(beta1)^2 - cos(g)^2 + 2*cos(alpha1)*cos(beta1)*cos(g))); %Volume of direct space cell

 
%reciprocal lattice calculations
%for example, see Als-Nielsen & McMorrow, Elements of Modern X-ray physics
my_s=2*pi;
aaR=my_s*(bb*cc*sin(alpha1)/VV); %in nm-1
bbR=my_s*(cc*aa*sin(beta1)/VV);
ccR=my_s*(aa*bb*sin(g)/VV);

 
alpha1R = acos((cos(beta1)*cos(g)-cos(alpha1))/(sin(beta1)*sin(g))); %in radians
beta1R = acos((cos(alpha1)*cos(g)-cos(beta1))/(sin(alpha1)*sin(g)));
gR = acos((cos(alpha1)*cos(beta1)-cos(g))/(sin(alpha1)*sin(beta1)));

 
% alpha1Rdegree = alpha1R*180/pi
% beta1Rdegree = beta1R*180/pi
% gRdegree = gR * 180/pi

 
%% Matrix B - eq(3) from Busing & Levy
% Reciprocal space to crystal cartesian axes
BB = fnormal([aaR bbR*cos(gR) ccR*cos(beta1R);0 bbR*sin(gR) -ccR*sin(beta1R)*cos(alpha1R);0 0 1/cc*my_s],9); %ok

 
MMM = [1 0 0;0 -1 0;0 0 1];

 
% kilab=[0;2*pi/lambda;0];
u1phi = motor_position(90,0,0);
u1phi = fnormal(u1phi,9);
u2phi = motor_position(180,0,0);
u2phi = fnormal(u2phi,9);

 
h1c = BB(:,3);
h2c = fnormal(BB(:,2),9);

 
%orthonormal set in the crystal cartesian system (generated by the BB
%matrix)
t1c = fnormal(h1c/sqrt(h1c(1)^2+h1c(2)^2+h1c(3)^2),9);
t3c = fnormal(cross(t1c,h2c)./norm(cross(t1c,h2c)),9);
t2c = fnormal(cross(t3c,t1c)./norm(cross(t3c,t1c)),9);

 
%orthonormal set in the phi reference system
t1phi = u1phi./sqrt(u1phi(1)^2+u1phi(2)^2+u1phi(3)^2);
t3phi = cross(t1phi,u2phi)./norm(cross(t1phi,u2phi));
t2phi = cross(t3phi,t1phi)./norm(cross(t3phi,t1phi));

 
Tc = [t1c t2c t3c];
Tphi = [t1phi t2phi t3phi];

 
% Orientation matrix U

 
UU = Tphi*inv(Tc);

 
IBB = inv(BB);
% Z = [0;1;0];
% hc = bsxfun(@times,BB,Z);
% q=norm(hc);

 
UB = fnormal(UU*BB,9);

 
%% Conversion from degrees to radians
gam = input1*pi/180;
alp = input2*pi/180;
chi = input3*pi/180;
phi = input4*pi/180;
om  = input5*pi/180;
del = input6*pi/180;

 
output = myIPXO2(UB,phi,chi,om,alp,del,lambda,gam);

 
end

 

 

 
%%%%%%%%%%%%%%%% Nested functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 
%%%%%%%%%%%%%%%% Matrices %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% for the matrices eq 8 to 15 from Busing & Levy
function output=mat1(input)
output = [cos(input) sin(input) 0;-sin(input) cos(input) 0;0 0 1];% rotation around z -> Rz alp,gam,omega,phi(with chi=0!)
end

 
function output=mat2(input)
output = [cos(input) 0 sin(input);0 1 0;-sin(input) 0 cos(input)];% rotation around y -> Ry chi,
end
%for the matrix A eq 6 from Lohmeier & Vlieg
function output=mat3(input)
output = [1 0 0;0 cos(input) -sin(input);0 sin(input) cos(input)];% rotation around x -> Rx del,
end
%for the matrix Gam2 from VS
function [output]=mat4(input)
output = [cos(input) -sin(input) 0;sin(input) cos(input) 0;0 0 1];% rotation around z -> Rz  gam2
end

 
%%%%%%%%%%%%%%% ki and kf %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function output=kialpha(input1,input2)
%input2 must be the angle and input1 the wavelength
kilab=[0;2*pi/input1;0];
output = inv(mat1(input2))*kilab;%VS
end

 
function [output]=kfalpha(input1,input2,input3,input4)
%input1 : wavelength; input2 : gamma; input3 : alpha; input4 : delta
kilab=[0;2*pi/input1;0];
output = mat4(-input2+input3)*mat3(input4)*kilab;%VS 
% size(output)
end

 
%%%%%%%%%%%%%%% motor_position and related functions %%%%%%%%%%%%%%%%%%%%%
function [output]=motor_position(om,ph,ch)
% Motor positions : chi phi omega

 
omega=om*pi/180;
phi=ph*pi/180;
chi=ch*pi/180;

 
output = myIPXO(omega,phi,chi);

 
end

 
function [output]=myIPXO(input1,input2,input3)
%input1 : chi; input2 : phi; input3: omega

 
% A=mat1(input1);
% B=mat1(input2);
% C=mat2(input3);
% myIPXO:= MatrixInverse(Phi) . MatrixInverse(XX) . MatrixInverse(Omega) . <1,0,0>  :
    output= inv(mat1(input2)) *  inv(mat2(input1))*  inv(mat1(input3))   * [1;0;0];

    
end

 
%%%%%%%%%%%%%%% myIPXO2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [output]=myIPXO2(input1,input2,input3,input4,input5,input6,input7,input8)
%input1 : UB; input2 : phi; input3 : chi; input4 : omega
%input5 : alpha ; input6 : delta; input7 : wavelength
%input8 : gamma
size(inv(input1));
size(inv(mat1(input2)));
size(inv(mat2(input3)));
size(inv(mat1(input4)));
size(kfalpha(input7,input8,input5,input6));
size(kialpha(input7,input5));
% myIPXO2:= MatrixInverse(UB) . MatrixInverse(Phi) . MatrixInverse(XX) . MatrixInverse(Omega) . (kfalpha -  kialpha):
      output = inv(input1)    * inv(mat1(input2))  *  inv(mat2(input3))*  inv(mat1(input4))   *(kfalpha(input7,input8,input5,input6) - kialpha(input7,input5));

 
end

